#!/usr/bin/env bash

set -e

err() 
{
    out=$1
    shift
    echo "$@" >&2
    exit $out
}


usage() {
    local action=$1
    
    if [ -z "$action" ]; then
	    echo "Usage: `basename $0` cmd

Available cmds:
ls      - display all stashed patshes
show    - view a given patch
save    - save a new patch or update existing one without file reverting
apply   - apply a given patch without deleting it
push    - save a new patch or update existing one and revert files
pop     - apply a patch and delete it
rm      - delete a given patch from the queue
sync    - synchornize the stash directory is using a VCS
help    - show help" >&2
        return
    fi
    
    #set -x
    eval echo '${'${action}_usage'}' >&2
}

export LC_ALL=C

[ -x `which svn` ] || err 1 "svn is not installed on this system"
svnrp=$(svn info 2>&1 | sed -n 's/Working Copy Root Path: \(.*\)/\1/p')
svnrev=$(svn info 2>&1 | grep '^Revision: ' | cut -d ' ' -f 2)
 
[ -d "${svnrp}" ] || err 1 "should be used inside a working copy"
[ -w "${svnrp}/.svn" ] || err 1 "no write access to ${svnrp}/.svn"
patchdir=${svnrp}/.svn/patches
mkdir -p "${patchdir}" || err 1 "Impossible to create the patch directory"
[ -d ${patchdir}/.svn ] && VCS="svn"
[ -f ${patchdir}/.fslckout ] && VCS="fossil"
[ -d ${patchdir}/.git ] && VCS="git"
[ -d ${patchdir}/.hg ] && VCS="hg"

_save()
{
    name=$1
    patch="${patchdir}/$1"
    diff="${patch}/changes.diff"
    others="${patch}/others.list"
    rev="${patch}/rev"

    shift
    while getopts 'ukf' FLAG; do
	case ${FLAG} in
	    u) update=yes ;;
	    k) keep=yes ;;
	    f) force=yes ;;
	esac
    done
    shift $(( $OPTIND - 1))

    if [ -z "${update}" -a -d "${patch}" ]; then
	err 1 "A patch named ${name} already exists, try option -u to force update it."
    fi

    mkdir -p "${patch}"
    
    files="$@"

    if [ -z "${files}" ]; then
	changes=$(svn st -q ${files})
	[ "${changes}" != "" ] || err 1 "No changes to be saved"

	svn diff --git ${files:-.} > "${diff}"
	if [ -z "${keep}" ]; then
	    svn revert --depth=infinity ${files:-.}
	    if [ -n "${force}" ]; then
		svn st ${files} | awk '/^?/ { print $2 }' | xargs rm -f
	    fi
	fi
    else
	diff_list="${patch}/diff.list.tmp"
	revert_list="${patch}/revert.list.tmp"
	
	rm -f "${others}" "${diff_list}" "${revert_list}"
	
	echo ${svnrev} > "${rev}"
	svn st ${files} | while read line
	do
	    type=`echo "$line" | tr -s ' ' | cut -d ' ' -f 1`
	    file=`echo "$line" | tr -s ' ' | cut -d ' ' -f 2-`

	    if [ "$type" = "?" ]; then
		fname=`realpath -m --relative-to="$svnrp" -s -q $file`
		fdir=`dirname "${fname}"`
		fn=`basename "${fname}"`
		mkdir -p "${patch}/${fdir}"
		cp "${file}" "${patch}/${fdir}/"

		echo "${fname}" >> "${others}"
		echo "${file}" >> "${revert_list}"
	       
	    else
		echo "${file}" >> "${diff_list}"	    
	    fi
	    
	done

	set -x
	if [ -f "$diff_list" ]; then	   
	    svn diff --git $(cat "$diff_list") > "${diff}"
	    cat "$diff_list" >> "$revert_list"
	fi

	if [ -f "$revert_list" ]; then
	    if [ -z "${keep}" ]; then
		if [ -n "${force}" ]; then
		    svn st $(cat "$diff_list") | awk '/^?/ {print $2}' | xargs -I{} rm -f {}
		fi
		svn st $(cat "$diff_list") | awk '/^M/ {print $2}' | xargs -I{} svn revert {}
	    fi
	fi	
    fi
    
#    if [ -n "${update}" -a -n "${VCS}" ]; then
#	(cd ${patchdir}; ${VCS} commit)
#    elif [ -n "${VCS}" ]; then
#	(cd ${patchdir}; ${VCS} add ${patch##*/}; ${VCS} commit)
#    fi
    
    echo "stashed"
    exit 0    
}

save_usage="
Usage: `basename $0` save <name> [-uf] [files...]\n
Where:\n
  name - stash name\n
  -u   - update stash VCS\n
"
save()
{
    [ $# -ge 1 ] || err 1 "$save_usage"
    x=`echo $1|head -c1`
    [ $x != "." ] || err 1 "The patch name must not start with '.'"
    name=$1
    shift
    _save $name -k "$@"
}

list()
{
    ls -t1 ${patchdir} | while read p; do
	[ -d ${patchdir}/$p ] && echo $p
    done | nl | awk '{printf("{%s}\t%s\n", $1, $2);}'
    exit 0
}

_get_patch()
{
    patch="$patchdir/$1"
    if [ -d "$patch" ]; then
	echo $patch
	return 0
    fi

    nm=$(list | grep "^$1" | awk '{print $2}')
    [ -z "$nm" ] && return 1
    echo "$patchdir/$nm"
}

show()
{
    set -x
    [ $# -eq 1 ] || err 1 "Usage: `basename $0` show <name|number>"
    patch=$(_get_patch $1)

    [ -z "$patch" -o -d "${patch}" ] || err 1 "$1: no such patch"

    [ "$patch/changes.diff" ] && cat "${patch}/changes.diff" | colordiff --color=auto

    # TODO: process untracked files
    
    exit 0
}


#
# Official way to apply patches between revisions
#
_apply_heavy() {
    local patch="$(_get_patch %1)"
    [ -f "${patch}" ] || err 1 "$1: no such patch"
    cd ${svnrp}	
	
    svn patch --dry-run --strip 1 "${patch}"
    status=$?	

    patch_rev=$(cat $patch | grep '^--- a.\+(revision \([0-9]\+\))' | sed 's|^--- a.\+(revision \([0-9]\+\))$|\1|' | head -n1)
    work_rev=$(svn info | grep '^Revision:' | awk '{print $2}')
    
    # Switch back (forward?) to Patch revision
    if [ $patch_rev -ne $work_rev ]; then
        echo "Switch to stashed revision: $patch_rev"
        svn update -r $patch_rev > /dev/null
    fi

    # Apply patch
    svn patch --strip 1 "${patch}"
    
    # And switch to work revision back, it helps to solve conflicts in interactive way
    if [ $patch_rev -ne $work_rev ]; then
        echo "Pop work revision back: $work_rev"
        svn update -r $work_rev > /dev/null
    fi
}


#
# NOT WORK NOW!
# But should work for files that changed and uncommitted in work copy.
#
_apply_lite() {
    local patch="${patchdir}/$1.patch"
	[ -f "${patch}" ] || err 1 "$1: no such patch"
	cd ${svnrp}	
	
	svn patch --dry-run --strip 1 "${patch}"

    patch_rev=$(cat $patch | grep '^--- a.\+(revision \([0-9]\+\))' | sed 's|^--- a.\+(revision \([0-9]\+\))$|\1|' | head -n1)
    work_rev=$(svn info | grep '^Revision:' | awk '{print $2}')
    
    conflicts=$(svn patch --dry-run --strip 1 "${patch}" | grep '^C')
    
    if [ -n "$conflicts" ]; then
    
        echo "Lite merging..."
    
        local files="$(svn patch --dry-run --strip 1 "${patch}" | grep '^[ADUCG]' | awk '{print $2}')"
        local tmp="$(mktemp -d /tmp/XXXXXXXXXX)"
        
        trap "rm -rf '$tmp'" RETURN EXIT
        
        echo "Use temp directory: $tmp"
    
        repo_url=$(svn info | grep '^URL:' | awk '{print $2}')
        
        echo "Repo URL: $repo_url"
    
        local CWD=`pwd`
    
        # Patch base
        mkdir -p $tmp/base
        svn co $repo_url $tmp/base --depth empty
        cd $tmp/base
        echo svn up -r $patch_rev $files
        svn up --depth infinity -r $patch_rev $files
        
        
        exit 0
        
        # Apply patch to given files
        local patch_full="$(realpath ${patch})"
        cd $tmp
        cp -a base new
        cd new
        svn patch --strip 1 "${patch_full}"
        
        # Use external tool for merging
        cd $CWD
        for file in $files
        do
            bn="$(dirname $file)"
            out="$tmp/out/$file"
            
            mkdir -p "$tmp/out/$bn"
        
            kdiff3 -m --auto $tmp/base/$file $tmp/new/$file $file -o $out &&
                cp $out $file || echo "Skip merging: $file"

        done
        
        #rm -rf $tmp
            
    else
        svn patch --strip 1 "${patch}"
    fi    
}

#
# Official way to apply patches between revisions. Lite version.
#
_apply_lite2() {
    local patch="$(_get_patch %1)"
    [ -f "${patch}" ] || err 1 "$1: no such patch"
    cd ${svnrp}	
	
    svn patch --dry-run --strip 1 "${patch}"

    local patch_rev="$(cat $patch | grep '^--- a.\+(revision \([0-9]\+\))' | sed 's|^--- a.\+(revision \([0-9]\+\))$|\1|' | head -n1)"
    local work_rev="$(svn info | grep '^Revision:' | awk '{print $2}')"
    local files="$(svn patch --dry-run --strip 1 "${patch}" | grep '^[ADUCG]' | awk '{print $2}')"
    
    # Switch back (forward?) to Patch revision
    if [ $patch_rev -ne $work_rev ]; then
        echo "Switch to stashed revision: $patch_rev"
        svn up -r $patch_rev $files
        #> /dev/null
    fi

    # Apply patch
    svn patch --strip 1 "${patch}"
    
    # And switch to work revision back, it helps to solve conflicts in interactive way
    if [ $patch_rev -ne $work_rev ]; then
        echo "Pop work revision back: $work_rev"
        svn up -r $work_rev $files 
        #> /dev/null
    fi
}

apply() {
    [ $# -eq 1 ] || err 1 "Usage: `basename $0` apply <name>"
    _apply_lite2 "$@"
    exit 0
}

remove() {
    [ $# -eq 1 ] || err 1 "Usage: `basename $0` rm <name>"
    patch="${patchdir}/$1.patch"
    [ -f "${patch}" ] || err 1 "$1: no such patch"
    rm -f "${patch}"
    if [ -n "${VCS}" ]; then
	(cd ${patchdir}; ${VCS} rm ${patch##*/}; ${VCS} commit)
    fi
    exit 0
}

pop() {
    [ $# -eq 1 ] || err 1 "Usage: `basename $0` pop <name>"
    _apply_lite2 "$@"	
    remove $1
    exit 0
}

push_usage="
Usage: `basename $0` push <name> [-uf] [files...]\n
Where:\n
  name - stash name\n
  -u   - update stash VCS\n
  -f   - force reverting non-versioning files.\n
"
push() {
    [ $# -ge 1 ] || err 1 "$push_usage"
    x=`echo $1|head -c1`
    [ $x != "." ] || err 1 "The patch name must not start with '.'"
    name=$1
    shift
    _save $name "$@"
}


sync() {
	[ -n "${VCS}" ] || err 1 "the stash is not being versioned"
	cd ${patchdir}
	case ${VCS} in
	hg) hg pull -u && hg push ;;
	git) git pull -r && git push ;;
	fossil) fossil sync && fossil update ;;
	svn) svn update ;;
	esac
	exit 0
}

cmd=$1
[ -n "$1" ] && shift

case "$cmd" in
ls) list "$@" ;;
show|save|apply|pop|push|sync|list) $cmd "$@" ;;
rm) remove "$@" ;;
*) usage "$@" ;;
esac
